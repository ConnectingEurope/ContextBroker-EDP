import requests
from flask import Flask
from flask import render_template
from flask import request
from flask import Response
from werkzeug.routing import BaseConverter

import cb_edp.config.constants as const
import cb_edp.config.messages as msg
from cb_edp.errors.api import APIProcessError
from cb_edp.errors.api import CouldNotReadRDFError
from cb_edp.utils.helpers import Helpers


class RegexConverter(BaseConverter):
	def __init__(self, url_map, *items):
		super(RegexConverter, self).__init__(url_map)
		self.regex = items[0]


app = Flask(__name__)
app.url_map.converters['regex'] = RegexConverter
default_offset = 0
default_limit = 1000


@app.route(const.API_URL_STRUCTURE.format(route='<orion>/entity/<datamodel>'))
def by_entity(rel_path, orion, datamodel):
	"""
	Makes a query to Orion API filtering by entity type.

	:param str rel_path: Relative path from a regex where the API is located (its value is never used)
	:param str orion: Base64 encoded Orion host
	:param str datamodel: Data Model (entity) by which the filter will be done
	:return: Query response to Orion API call
	:rtype: (str, int, ItemsView)
	"""
	headers = build_headers(request)

	orion_host = Helpers.decode_base64_url(orion)
	url = build_url(orion_host, datamodel, request)
	return make_request(url, headers, complete=check_if_complete_request(request))


@app.route(const.API_URL_STRUCTURE.format(route='<orion>/entity/<datamodel>/location/<location>'))
def by_location(rel_path, orion, datamodel, location):
	"""
	Makes a query to Orion API filtering by an entity type and a geographical area.

	:param str rel_path: Relative path from a regex where the API is located (its value is never used)
	:param str orion: Base64 encoded Orion host
	:param str datamodel: Data Model (entity) by which the filter will be done
	:param str location: Name of a geographical area (political location) to filter the query
	:return: Query response to Orion API call
	:rtype: (str, int, ItemsView)
	"""
	headers = build_headers(request)

	orion_host = Helpers.decode_base64_url(orion)
	url = build_url(orion_host, datamodel, request)
	url += const.API_FIWARE_URL_STRUCTURE_LOCATION.format(location=location)
	return make_request(url, headers, complete=check_if_complete_request(request))


@app.route(const.API_URL_STRUCTURE.format(route=const.RDF_FILE_NAME))
def rdf(rel_path):
	"""
	Reads the RDF file generated by the integration and returns it in request's response.

	:param str rel_path: Relative path from a regex where the API is located (its value is never used)
	:return: Generated RDF/XML file
	:rtype: Response
	:raises CouldNotReadRDFError APIProcessError:
	"""
	try:
		with open(Helpers.get_rdf_path(), 'r') as file:
			rdf_xml = file.read()
		response = Response()
		response.mimetype = 'application/rdf+xml'
		response.data = rdf_xml
		return response
	except FileNotFoundError:
		raise CouldNotReadRDFError
	except:
		raise APIProcessError


@app.route(const.API_URL_STRUCTURE.format(route=const.API_URL_STATUS))
def status(rel_path):
	"""
	Dummy method that returns a plain response just to check that the API works fine.

	:param str rel_path: Relative path from a regex where the API is located (its value is never used)
	:return: Plain empty response
	:rtype: Response
	"""
	return Response(msg.API_STATUS_OK)


@app.errorhandler(CouldNotReadRDFError)
@app.errorhandler(APIProcessError)
def handle_custom_api_errors(exception):
	"""
	Exception handler for those custom errors produced by the Integration Solution API.

	:param CouldNotReadRDFError or APIProcessError exception: Custom error raised by APIs methods
	:return: Error page template with a brief error description
	"""
	return render_template('error.html', error_code=exception.status_code, title=exception.short_message,
						   message=exception.message)


def build_url(host, entity, request):
	"""
	Generates the URL to make the call to Orion API filtering by an entity type.

	:param str host: Host address where Orion is reachable
	:param str entity: Entity name by which the filter will be done
	:param Request request: Request object representing the one made by the user
	:return: Well-formed URL to Orion API
	:rtype: str
	"""
	if host[-1] is '/':
		host = host[:-1]

	offset = request.args.get('offset')
	limit = request.args.get('limit')
	if not offset:
		offset = default_offset
	if not limit:
		limit = default_limit

	return const.API_FIWARE_URL_STRUCTURE.format(host=host, entity=entity, offset=offset, limit=limit)


def build_headers(request):
	"""
	Builds the headers to include in the API call to Orion based in received request.

	:param Request request: Instance of the petition used to query Orion API
	:return: Headers to include to the request
	:rtype: dict
	:raises APIProcessError:
	"""
	headers = {'Accept': 'application/json'}
	fiware_service = request.args.get('fs')
	fiware_service_path = request.args.get('fp')
	if fiware_service:
		headers[const.API_FIWARE_SERVICE] = Helpers.decode_base64_url(fiware_service)
		if fiware_service_path:
			headers[const.API_FIWARE_SERVICEPATH] = '/{service_path}'.format(
				service_path=Helpers.decode_base64_url(fiware_service_path))
	else:
		if fiware_service_path:
			raise APIProcessError
	return headers


def make_request(url, headers, method='get', complete=True):
	"""
	Makes a query and returns its response.

	:param str url: URL where the call is made
	:param dict headers: Orion's required headers to make a proper API call
	:param str method: HTTP method used in the request (default 'get')
	:param bool complete: Flag that indicates if the request should return every entity by the filter (default 'True')
	:return: Query response to Orion API call
	:rtype: (str, int, collections.abc.ItemsView)
	"""
	response = requests.request(method, url, headers=headers)
	content = response.content
	if complete and const.API_FIWARE_TOTAL_COUNT_HEADER in response.headers:
		limit = default_limit
		offset = default_offset + default_limit

		count = int(response.headers[const.API_FIWARE_TOTAL_COUNT_HEADER])
		if count > limit:
			import json, re
			content = json.loads(content)
			url = re.sub(r'(limit=)\d+', '\g<1>{number}'.format(number=limit), url)
			while offset < count:
				url = re.sub(r'(offset=)\d+', '\g<1>{number}'.format(number=offset), url)
				response = requests.request(method, url, headers=headers)
				content += json.loads(response.content)
				offset += limit
			content = json.dumps(content)

	# Headers removal when gzip content returned to avoid encoding misunderstandings
	for header in const.API_FIWARE_RESPONSE_IGNORE_HEADERS:
		if header in response.headers:
			response.headers.pop(header)

	return content, response.status_code, response.headers.items()


def check_if_complete_request(request):
	"""
	Verifies if the request done by the user specifies any of the pagination parameters.

	:param Request request: Request object representing the one made by the user
	:return: If the user specifies one of the pagination URL parameters
	:rtype: bool
	"""
	return not request.args.get('offset') and not request.args.get('limit')


if __name__ == '__main__':
	app.run()
